<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Shortcut Tile</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { width: 100%; height: 100%; overflow: hidden; background: transparent; pointer-events: none; }

    .tile {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 8px;
      padding: 16px;
      width: 100%;
      height: 100%;
      cursor: pointer;
      user-select: none;
      pointer-events: auto;
      transition: transform 0.2s cubic-bezier(0.34, 1.56, 0.64, 1),
                  box-shadow 0.2s ease,
                  background-color 0.2s ease;
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 16px;
    }

    .tile:hover {
      transform: scale(var(--hover-scale, 1.08));
    }

    .tile:active {
      transform: scale(var(--click-scale, 0.95));
    }

    .tile.glow-enabled {
      box-shadow: 0 0 var(--glow-intensity, 10px) var(--glow-color, rgba(139, 92, 246, 0.5));
    }

    .tile.glow-enabled:hover {
      box-shadow: 0 0 calc(var(--glow-intensity, 10px) * 1.5) var(--glow-color, rgba(139, 92, 246, 0.7));
    }

    .icon-container {
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }

    .icon {
      width: var(--icon-size, 48px);
      height: var(--icon-size, 48px);
      object-fit: contain;
    }

    .icon-emoji {
      font-size: var(--icon-size, 48px);
      line-height: 1;
      text-align: center;
    }

    .label {
      font-weight: 500;
      text-align: center;
      text-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 100%;
    }

    .tile.error {
      border-color: rgba(239, 68, 68, 0.5);
    }

    @keyframes pulse {
      0% { opacity: 1; }
      50% { opacity: 0.7; }
      100% { opacity: 1; }
    }

    .tile.clicked {
      animation: pulse 0.3s ease;
    }
  </style>
</head>
<body>
  <div class="tile" id="tile" tabindex="0" role="button">
    <div class="icon-container">
      <img class="icon" id="icon-img" src="" alt="" style="display: none;">
      <span class="icon-emoji" id="icon-emoji" style="display: none;"></span>
    </div>
    <div class="label" id="label"></div>
  </div>

  <script>
    // ==========================================================================
    // APP PRESETS - Protocols, icons and labels for popular applications
    // ==========================================================================
    const APP_PRESETS = {
      spotify: {
        protocol: 'spotify://',
        emoji: 'ðŸŽµ',
        label: 'Spotify',
        icon: 'https://upload.wikimedia.org/wikipedia/commons/8/84/Spotify_icon.svg'
      },
      discord: {
        protocol: 'discord://',
        emoji: 'ðŸ’¬',
        label: 'Discord',
        icon: 'https://assets-global.website-files.com/6257adef93867e50d84d30e2/6257d23c5fb25be7e0b6e220_Open%20Source%20Projects%20702702b9ac54dd3a999140.svg'
      },
      vscode: {
        protocol: 'vscode://',
        emoji: 'ðŸ’»',
        label: 'VS Code',
        icon: 'https://upload.wikimedia.org/wikipedia/commons/9/9a/Visual_Studio_Code_1.35_icon.svg'
      },
      slack: {
        protocol: 'slack://',
        emoji: 'ðŸ“¢',
        label: 'Slack',
        icon: 'https://upload.wikimedia.org/wikipedia/commons/d/d5/Slack_icon_2019.svg'
      },
      telegram: {
        protocol: 'tg://',
        emoji: 'âœˆï¸',
        label: 'Telegram',
        icon: 'https://upload.wikimedia.org/wikipedia/commons/8/82/Telegram_logo.svg'
      },
      steam: {
        protocol: 'steam://',
        emoji: 'ðŸŽ®',
        label: 'Steam',
        icon: 'https://upload.wikimedia.org/wikipedia/commons/8/83/Steam_icon_logo.svg'
      },
      obs: {
        protocol: 'obsproject://',
        emoji: 'ðŸŽ¥',
        label: 'OBS Studio',
        icon: 'https://upload.wikimedia.org/wikipedia/commons/1/14/Open_Broadcaster_Software_Logo.png'
      },
      figma: {
        protocol: 'figma://',
        emoji: 'ðŸŽ¨',
        label: 'Figma',
        icon: 'https://upload.wikimedia.org/wikipedia/commons/3/33/Figma-logo.svg'
      },
      notion: {
        protocol: 'notion://',
        emoji: 'ðŸ“',
        label: 'Notion',
        icon: 'https://upload.wikimedia.org/wikipedia/commons/4/45/Notion_app_logo.png'
      },
      chrome: {
        protocol: 'googlechrome://',
        emoji: 'ðŸŒ',
        label: 'Chrome',
        icon: 'https://upload.wikimedia.org/wikipedia/commons/e/e1/Google_Chrome_icon_%28February_2022%29.svg'
      },
      firefox: {
        protocol: 'firefox://',
        emoji: 'ðŸ¦Š',
        label: 'Firefox',
        icon: 'https://upload.wikimedia.org/wikipedia/commons/a/a0/Firefox_logo%2C_2019.svg'
      },
      terminal: {
        protocol: 'x-terminal-emulator://',
        emoji: 'â¬›',
        label: 'Terminal',
        icon: null
      }
    };

    class ShortcutTile {
      constructor() {
        this.tile = document.getElementById('tile');
        this.iconImg = document.getElementById('icon-img');
        this.iconEmoji = document.getElementById('icon-emoji');
        this.labelEl = document.getElementById('label');
        this.isFirstRender = true;
        this.fileBlobUrl = null;

        const config = window.MyWallpaper?.config || {};

        this.settings = {
          // Action settings
          actionMode: config.actionMode ?? 'preset',
          appPreset: config.appPreset ?? 'spotify',
          targetUrl: config.targetUrl ?? 'https://github.com',
          targetFile: config.targetFile ?? null,
          targetFolder: config.targetFolder ?? '',
          targetProtocol: config.targetProtocol ?? '',
          // Icon settings
          iconSource: config.iconSource ?? 'auto',
          iconEmoji: config.iconEmoji ?? 'ðŸš€',
          iconUrl: config.iconUrl ?? '',
          iconFile: config.iconFile ?? null,
          iconSize: config.iconSize ?? 48,
          // Label settings
          showLabel: config.showLabel ?? true,
          labelMode: config.labelMode ?? 'auto',
          labelCustom: config.labelCustom ?? '',
          labelSize: config.labelSize ?? 14,
          labelColor: config.labelColor ?? '#ffffff',
          // Tile settings
          tileColor: config.tileColor ?? '#ffffff',
          tileOpacity: config.tileOpacity ?? 10,
          blurAmount: config.blurAmount ?? 12,
          borderRadius: config.borderRadius ?? 16,
          borderWidth: config.borderWidth ?? 1,
          borderColor: config.borderColor ?? '#ffffff',
          borderOpacity: config.borderOpacity ?? 20,
          // Effects
          enableGlow: config.enableGlow ?? true,
          glowColor: config.glowColor ?? '#8b5cf6',
          glowIntensity: config.glowIntensity ?? 10,
          hoverScale: config.hoverScale ?? 1.08,
          clickScale: config.clickScale ?? 0.95
        };

        this.init();
      }

      init() {
        this.applySettings();
        this.setupEventListeners();

        if (this.isFirstRender && window.MyWallpaper) {
          this.isFirstRender = false;
          window.MyWallpaper.renderComplete();
        }
      }

      hexToRgba(hex, alpha) {
        const r = parseInt(hex.slice(1, 3), 16);
        const g = parseInt(hex.slice(3, 5), 16);
        const b = parseInt(hex.slice(5, 7), 16);
        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
      }

      // Get the current preset data (if in preset mode)
      getCurrentPreset() {
        if (this.settings.actionMode === 'preset') {
          return APP_PRESETS[this.settings.appPreset] || null;
        }
        return null;
      }

      // Get the target path based on action mode
      getTargetPath() {
        const s = this.settings;
        switch (s.actionMode) {
          case 'preset':
            const preset = APP_PRESETS[s.appPreset];
            return preset ? preset.protocol : '';
          case 'url':
            return s.targetUrl;
          case 'file':
            return this.fileBlobUrl || s.targetFile;
          case 'folder':
            return s.targetFolder;
          case 'custom':
            return s.targetProtocol;
          default:
            return '';
        }
      }

      // Get the action type for system.openPath
      getActionType() {
        const s = this.settings;
        switch (s.actionMode) {
          case 'preset':
          case 'custom':
            return 'protocol';
          case 'url':
            return 'url';
          case 'file':
            return 'file';
          case 'folder':
            return 'folder';
          default:
            return 'auto';
        }
      }

      // Determine icon to display
      applyIcon() {
        const s = this.settings;
        const preset = this.getCurrentPreset();

        this.iconImg.style.display = 'none';
        this.iconEmoji.style.display = 'none';

        // Icon size
        this.tile.style.setProperty('--icon-size', `${s.iconSize}px`);

        // Determine icon source
        let source = s.iconSource;
        if (source === 'auto' && preset) {
          // Auto mode with preset: use preset icon or emoji
          if (preset.icon) {
            this.iconImg.src = preset.icon;
            this.iconImg.style.display = 'block';
            return;
          } else {
            this.iconEmoji.textContent = preset.emoji;
            this.iconEmoji.style.display = 'block';
            return;
          }
        }

        // Manual icon selection
        switch (source) {
          case 'auto':
          case 'emoji':
            const emoji = (source === 'auto' && preset) ? preset.emoji : s.iconEmoji;
            this.iconEmoji.textContent = emoji || 'ðŸš€';
            this.iconEmoji.style.display = 'block';
            break;
          case 'url':
            if (s.iconUrl) {
              this.iconImg.src = s.iconUrl;
              this.iconImg.style.display = 'block';
            } else {
              this.iconEmoji.textContent = 'ðŸš€';
              this.iconEmoji.style.display = 'block';
            }
            break;
          case 'file':
            if (s.iconFile && window.MyWallpaper?.files?.isFileReference(s.iconFile)) {
              window.MyWallpaper.files.request('iconFile').then(result => {
                if (result.granted && result.blobUrl) {
                  this.iconImg.src = result.blobUrl;
                  this.iconImg.style.display = 'block';
                  this.iconEmoji.style.display = 'none';
                }
              });
            } else {
              this.iconEmoji.textContent = 'ðŸš€';
              this.iconEmoji.style.display = 'block';
            }
            break;
        }
      }

      // Determine label to display
      applyLabel() {
        const s = this.settings;
        const preset = this.getCurrentPreset();

        this.labelEl.style.display = s.showLabel ? 'block' : 'none';
        this.labelEl.style.fontSize = `${s.labelSize}px`;
        this.labelEl.style.color = s.labelColor;

        // Determine label text
        let labelText = '';
        if (s.labelMode === 'auto') {
          if (preset) {
            labelText = preset.label;
          } else if (s.actionMode === 'url') {
            try {
              labelText = new URL(s.targetUrl).hostname;
            } catch {
              labelText = 'URL';
            }
          } else if (s.actionMode === 'file') {
            labelText = 'Fichier';
          } else if (s.actionMode === 'folder') {
            labelText = 'Dossier';
          } else {
            labelText = 'Raccourci';
          }
        } else {
          labelText = s.labelCustom || 'Raccourci';
        }

        this.labelEl.textContent = labelText;
      }

      applySettings() {
        const s = this.settings;

        // Apply icon
        this.applyIcon();

        // Apply label
        this.applyLabel();

        // Tile background (glassmorphism)
        this.tile.style.background = this.hexToRgba(s.tileColor, s.tileOpacity / 100);

        // Blur
        this.tile.style.backdropFilter = `blur(${s.blurAmount}px)`;
        this.tile.style.webkitBackdropFilter = `blur(${s.blurAmount}px)`;

        // Border
        this.tile.style.border = `${s.borderWidth}px solid ${this.hexToRgba(s.borderColor, s.borderOpacity / 100)}`;
        this.tile.style.borderRadius = `${s.borderRadius}px`;

        // Glow effect
        if (s.enableGlow) {
          this.tile.classList.add('glow-enabled');
          this.tile.style.setProperty('--glow-color', this.hexToRgba(s.glowColor, 0.5));
          this.tile.style.setProperty('--glow-intensity', `${s.glowIntensity}px`);
        } else {
          this.tile.classList.remove('glow-enabled');
        }

        // Hover/click scale
        this.tile.style.setProperty('--hover-scale', s.hoverScale);
        this.tile.style.setProperty('--click-scale', s.clickScale);

        // Load file if needed
        if (s.actionMode === 'file' && s.targetFile) {
          this.loadTargetFile();
        }
      }

      async loadTargetFile() {
        const s = this.settings;
        if (s.targetFile && window.MyWallpaper?.files?.isFileReference(s.targetFile)) {
          try {
            const result = await window.MyWallpaper.files.request('targetFile');
            if (result.granted && result.blobUrl) {
              this.fileBlobUrl = result.blobUrl;
            }
          } catch (err) {
            console.error('[ShortcutTile] Failed to load file:', err);
          }
        }
      }

      async handleClick() {
        const targetPath = this.getTargetPath();
        const actionType = this.getActionType();

        if (!targetPath) {
          console.warn('[ShortcutTile] No target configured');
          this.tile.classList.add('error');
          setTimeout(() => this.tile.classList.remove('error'), 2000);
          return;
        }

        // Visual feedback
        this.tile.classList.add('clicked');
        setTimeout(() => this.tile.classList.remove('clicked'), 300);

        console.log('[ShortcutTile] Opening:', targetPath, 'as', actionType);

        try {
          if (!window.MyWallpaper?.system?.openPath) {
            console.error('[ShortcutTile] SDK system.openPath not available');
            this.tile.classList.add('error');
            setTimeout(() => this.tile.classList.remove('error'), 2000);
            return;
          }

          const result = await window.MyWallpaper.system.openPath(targetPath, {
            type: actionType
          });

          if (result.success) {
            console.log('[ShortcutTile] Opened successfully');
          }
        } catch (err) {
          console.error('[ShortcutTile] Error:', err.message);
          this.tile.classList.add('error');
          setTimeout(() => this.tile.classList.remove('error'), 2000);
        }
      }

      setupEventListeners() {
        this.tile.addEventListener('click', () => this.handleClick());

        this.tile.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            this.handleClick();
          }
        });

        // Hot reload support
        if (window.MyWallpaper?.onSettingsChange) {
          window.MyWallpaper.onSettingsChange((newSettings, changedKeys) => {
            console.log('[ShortcutTile] Settings changed:', changedKeys);
            Object.assign(this.settings, newSettings);
            this.applySettings();
          });
        }

        // Viewport resize
        if (window.MyWallpaper?.onEvent) {
          window.MyWallpaper.onEvent('viewport:resize', ({ width, height }) => {
            console.log(`[ShortcutTile] Viewport: ${width}x${height}`);
          });
        }
      }
    }

    // Initialize
    if (document.readyState === 'complete') {
      window.shortcutTile = new ShortcutTile();
    } else {
      window.addEventListener('load', () => {
        window.shortcutTile = new ShortcutTile();
      });
    }
  </script>
</body>
</html>
